/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.14.0 (NJsonSchema v9.10.52.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }
}

@Injectable()
export class ConfigurationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeUiTheme(input: ChangeUiThemeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Configuration/ChangeUiTheme";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeUiTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeUiTheme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeUiTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @userName (optional) 
     * @type (optional) 
     * @email (optional) 
     * @name (optional) 
     * @doB (optional) 
     * @phone (optional) 
     * @address (optional) 
     * @country (optional) 
     * @province (optional) 
     * @likeCount (optional) 
     * @followCount (optional) 
     * @city (optional) 
     * @occupation (optional) 
     * @about (optional) 
     * @description (optional) 
     * @websiteUrl (optional) 
     * @facebookUrl (optional) 
     * @twitterUrl (optional) 
     * @skypeName (optional) 
     * @viberNumber (optional) 
     * @pictureUrl (optional) 
     * @coverUrl (optional) 
     * @creationTime (optional) 
     * @isVerified (optional) 
     * @userId (optional) 
     * @isLiked (optional) 
     * @isFollowed (optional) 
     * @myRole (optional) 
     * @isAdmin (optional) 
     * @isEditor (optional) 
     * @isModerator (optional) 
     * @return Success
     */
    getPage(id: number | null | undefined, userName: string | null | undefined, type: string | null | undefined, email: string | null | undefined, name: string | null | undefined, doB: moment.Moment | null | undefined, phone: string | null | undefined, address: string | null | undefined, country: string | null | undefined, province: string | null | undefined, likeCount: number | null | undefined, followCount: number | null | undefined, city: string | null | undefined, occupation: string | null | undefined, about: string | null | undefined, description: string | null | undefined, websiteUrl: string | null | undefined, facebookUrl: string | null | undefined, twitterUrl: string | null | undefined, skypeName: string | null | undefined, viberNumber: string | null | undefined, pictureUrl: string | null | undefined, coverUrl: string | null | undefined, creationTime: moment.Moment | null | undefined, isVerified: boolean | null | undefined, userId: number | null | undefined, isLiked: boolean | null | undefined, isFollowed: boolean | null | undefined, myRole: MyRole | null | undefined, isAdmin: boolean | null | undefined, isEditor: boolean | null | undefined, isModerator: boolean | null | undefined): Observable<PageDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Page/GetPage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (doB !== undefined)
            url_ += "DoB=" + encodeURIComponent(doB ? "" + doB.toJSON() : "") + "&"; 
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&"; 
        if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&"; 
        if (country !== undefined)
            url_ += "Country=" + encodeURIComponent("" + country) + "&"; 
        if (province !== undefined)
            url_ += "Province=" + encodeURIComponent("" + province) + "&"; 
        if (likeCount !== undefined)
            url_ += "LikeCount=" + encodeURIComponent("" + likeCount) + "&"; 
        if (followCount !== undefined)
            url_ += "FollowCount=" + encodeURIComponent("" + followCount) + "&"; 
        if (city !== undefined)
            url_ += "City=" + encodeURIComponent("" + city) + "&"; 
        if (occupation !== undefined)
            url_ += "Occupation=" + encodeURIComponent("" + occupation) + "&"; 
        if (about !== undefined)
            url_ += "About=" + encodeURIComponent("" + about) + "&"; 
        if (description !== undefined)
            url_ += "Description=" + encodeURIComponent("" + description) + "&"; 
        if (websiteUrl !== undefined)
            url_ += "WebsiteUrl=" + encodeURIComponent("" + websiteUrl) + "&"; 
        if (facebookUrl !== undefined)
            url_ += "FacebookUrl=" + encodeURIComponent("" + facebookUrl) + "&"; 
        if (twitterUrl !== undefined)
            url_ += "TwitterUrl=" + encodeURIComponent("" + twitterUrl) + "&"; 
        if (skypeName !== undefined)
            url_ += "SkypeName=" + encodeURIComponent("" + skypeName) + "&"; 
        if (viberNumber !== undefined)
            url_ += "ViberNumber=" + encodeURIComponent("" + viberNumber) + "&"; 
        if (pictureUrl !== undefined)
            url_ += "PictureUrl=" + encodeURIComponent("" + pictureUrl) + "&"; 
        if (coverUrl !== undefined)
            url_ += "CoverUrl=" + encodeURIComponent("" + coverUrl) + "&"; 
        if (creationTime !== undefined)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toJSON() : "") + "&"; 
        if (isVerified !== undefined)
            url_ += "IsVerified=" + encodeURIComponent("" + isVerified) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (isLiked !== undefined)
            url_ += "IsLiked=" + encodeURIComponent("" + isLiked) + "&"; 
        if (isFollowed !== undefined)
            url_ += "IsFollowed=" + encodeURIComponent("" + isFollowed) + "&"; 
        if (myRole !== undefined)
            url_ += "MyRole=" + encodeURIComponent("" + myRole) + "&"; 
        if (isAdmin !== undefined)
            url_ += "IsAdmin=" + encodeURIComponent("" + isAdmin) + "&"; 
        if (isEditor !== undefined)
            url_ += "IsEditor=" + encodeURIComponent("" + isEditor) + "&"; 
        if (isModerator !== undefined)
            url_ += "IsModerator=" + encodeURIComponent("" + isModerator) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPage(<any>response_);
                } catch (e) {
                    return <Observable<PageDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPage(response: HttpResponseBase): Observable<PageDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageDetailDto.fromJS(resultData200) : new PageDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDetailDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    updatePage(model: PageDetailDto | null | undefined): Observable<PageDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Page/UpdatePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePage(<any>response_);
                } catch (e) {
                    return <Observable<PageDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePage(response: HttpResponseBase): Observable<PageDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageDetailDto.fromJS(resultData200) : new PageDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDetailDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    like(model: PageDetailDto | null | undefined): Observable<PageDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Page/Like";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLike(<any>response_);
                } catch (e) {
                    return <Observable<PageDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processLike(response: HttpResponseBase): Observable<PageDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageDetailDto.fromJS(resultData200) : new PageDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDetailDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    follow(model: PageDetailDto | null | undefined): Observable<PageDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Page/Follow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFollow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFollow(<any>response_);
                } catch (e) {
                    return <Observable<PageDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processFollow(response: HttpResponseBase): Observable<PageDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageDetailDto.fromJS(resultData200) : new PageDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDetailDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    unLike(model: PageDetailDto | null | undefined): Observable<PageDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Page/UnLike";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnLike(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnLike(<any>response_);
                } catch (e) {
                    return <Observable<PageDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processUnLike(response: HttpResponseBase): Observable<PageDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageDetailDto.fromJS(resultData200) : new PageDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDetailDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    unFollow(model: PageDetailDto | null | undefined): Observable<PageDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Page/UnFollow";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnFollow(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnFollow(<any>response_);
                } catch (e) {
                    return <Observable<PageDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processUnFollow(response: HttpResponseBase): Observable<PageDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PageDetailDto.fromJS(resultData200) : new PageDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageDetailDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @userName (optional) 
     * @type (optional) 
     * @email (optional) 
     * @name (optional) 
     * @doB (optional) 
     * @phone (optional) 
     * @address (optional) 
     * @country (optional) 
     * @province (optional) 
     * @likeCount (optional) 
     * @followCount (optional) 
     * @city (optional) 
     * @occupation (optional) 
     * @about (optional) 
     * @description (optional) 
     * @websiteUrl (optional) 
     * @facebookUrl (optional) 
     * @twitterUrl (optional) 
     * @skypeName (optional) 
     * @viberNumber (optional) 
     * @pictureUrl (optional) 
     * @coverUrl (optional) 
     * @creationTime (optional) 
     * @isVerified (optional) 
     * @userId (optional) 
     * @isLiked (optional) 
     * @isFollowed (optional) 
     * @myRole (optional) 
     * @isAdmin (optional) 
     * @isEditor (optional) 
     * @isModerator (optional) 
     * @return Success
     */
    getMembers(id: number | null | undefined, userName: string | null | undefined, type: string | null | undefined, email: string | null | undefined, name: string | null | undefined, doB: moment.Moment | null | undefined, phone: string | null | undefined, address: string | null | undefined, country: string | null | undefined, province: string | null | undefined, likeCount: number | null | undefined, followCount: number | null | undefined, city: string | null | undefined, occupation: string | null | undefined, about: string | null | undefined, description: string | null | undefined, websiteUrl: string | null | undefined, facebookUrl: string | null | undefined, twitterUrl: string | null | undefined, skypeName: string | null | undefined, viberNumber: string | null | undefined, pictureUrl: string | null | undefined, coverUrl: string | null | undefined, creationTime: moment.Moment | null | undefined, isVerified: boolean | null | undefined, userId: number | null | undefined, isLiked: boolean | null | undefined, isFollowed: boolean | null | undefined, myRole: MyRole2 | null | undefined, isAdmin: boolean | null | undefined, isEditor: boolean | null | undefined, isModerator: boolean | null | undefined): Observable<PageMemberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Page/GetMembers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (doB !== undefined)
            url_ += "DoB=" + encodeURIComponent(doB ? "" + doB.toJSON() : "") + "&"; 
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&"; 
        if (address !== undefined)
            url_ += "Address=" + encodeURIComponent("" + address) + "&"; 
        if (country !== undefined)
            url_ += "Country=" + encodeURIComponent("" + country) + "&"; 
        if (province !== undefined)
            url_ += "Province=" + encodeURIComponent("" + province) + "&"; 
        if (likeCount !== undefined)
            url_ += "LikeCount=" + encodeURIComponent("" + likeCount) + "&"; 
        if (followCount !== undefined)
            url_ += "FollowCount=" + encodeURIComponent("" + followCount) + "&"; 
        if (city !== undefined)
            url_ += "City=" + encodeURIComponent("" + city) + "&"; 
        if (occupation !== undefined)
            url_ += "Occupation=" + encodeURIComponent("" + occupation) + "&"; 
        if (about !== undefined)
            url_ += "About=" + encodeURIComponent("" + about) + "&"; 
        if (description !== undefined)
            url_ += "Description=" + encodeURIComponent("" + description) + "&"; 
        if (websiteUrl !== undefined)
            url_ += "WebsiteUrl=" + encodeURIComponent("" + websiteUrl) + "&"; 
        if (facebookUrl !== undefined)
            url_ += "FacebookUrl=" + encodeURIComponent("" + facebookUrl) + "&"; 
        if (twitterUrl !== undefined)
            url_ += "TwitterUrl=" + encodeURIComponent("" + twitterUrl) + "&"; 
        if (skypeName !== undefined)
            url_ += "SkypeName=" + encodeURIComponent("" + skypeName) + "&"; 
        if (viberNumber !== undefined)
            url_ += "ViberNumber=" + encodeURIComponent("" + viberNumber) + "&"; 
        if (pictureUrl !== undefined)
            url_ += "PictureUrl=" + encodeURIComponent("" + pictureUrl) + "&"; 
        if (coverUrl !== undefined)
            url_ += "CoverUrl=" + encodeURIComponent("" + coverUrl) + "&"; 
        if (creationTime !== undefined)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toJSON() : "") + "&"; 
        if (isVerified !== undefined)
            url_ += "IsVerified=" + encodeURIComponent("" + isVerified) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (isLiked !== undefined)
            url_ += "IsLiked=" + encodeURIComponent("" + isLiked) + "&"; 
        if (isFollowed !== undefined)
            url_ += "IsFollowed=" + encodeURIComponent("" + isFollowed) + "&"; 
        if (myRole !== undefined)
            url_ += "MyRole=" + encodeURIComponent("" + myRole) + "&"; 
        if (isAdmin !== undefined)
            url_ += "IsAdmin=" + encodeURIComponent("" + isAdmin) + "&"; 
        if (isEditor !== undefined)
            url_ += "IsEditor=" + encodeURIComponent("" + isEditor) + "&"; 
        if (isModerator !== undefined)
            url_ += "IsModerator=" + encodeURIComponent("" + isModerator) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMembers(<any>response_);
                } catch (e) {
                    return <Observable<PageMemberDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageMemberDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMembers(response: HttpResponseBase): Observable<PageMemberDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PageMemberDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageMemberDto[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    addMember(model: PageMemberDto | null | undefined): Observable<PageMemberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Page/AddMember";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddMember(<any>response_);
                } catch (e) {
                    return <Observable<PageMemberDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageMemberDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processAddMember(response: HttpResponseBase): Observable<PageMemberDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PageMemberDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageMemberDto[]>(<any>null);
    }

    /**
     * @pageUserName (optional) 
     * @role (optional) 
     * @user_UserName (optional) 
     * @user_EmailAddress (optional) 
     * @user_IsActive (optional) 
     * @user_Name (optional) 
     * @user_FullName (optional) 
     * @user_LastLoginTime (optional) 
     * @user_CreationTime (optional) 
     * @user_RoleNames (optional) 
     * @user_PictureUrl (optional) 
     * @user_PictureCoverUrl (optional) 
     * @user_Id (optional) 
     * @return Success
     */
    removeMember(pageUserName: string | null | undefined, role: Role | null | undefined, user_UserName: string | null | undefined, user_EmailAddress: string | null | undefined, user_IsActive: boolean | null | undefined, user_Name: string | null | undefined, user_FullName: string | null | undefined, user_LastLoginTime: moment.Moment | null | undefined, user_CreationTime: moment.Moment | null | undefined, user_RoleNames: string[] | null | undefined, user_PictureUrl: string | null | undefined, user_PictureCoverUrl: string | null | undefined, user_Id: number | null | undefined): Observable<PageMemberDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Page/RemoveMember?";
        if (pageUserName !== undefined)
            url_ += "PageUserName=" + encodeURIComponent("" + pageUserName) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (user_UserName !== undefined)
            url_ += "User.UserName=" + encodeURIComponent("" + user_UserName) + "&"; 
        if (user_EmailAddress !== undefined)
            url_ += "User.EmailAddress=" + encodeURIComponent("" + user_EmailAddress) + "&"; 
        if (user_IsActive !== undefined)
            url_ += "User.IsActive=" + encodeURIComponent("" + user_IsActive) + "&"; 
        if (user_Name !== undefined)
            url_ += "User.Name=" + encodeURIComponent("" + user_Name) + "&"; 
        if (user_FullName !== undefined)
            url_ += "User.FullName=" + encodeURIComponent("" + user_FullName) + "&"; 
        if (user_LastLoginTime !== undefined)
            url_ += "User.LastLoginTime=" + encodeURIComponent(user_LastLoginTime ? "" + user_LastLoginTime.toJSON() : "") + "&"; 
        if (user_CreationTime !== undefined)
            url_ += "User.CreationTime=" + encodeURIComponent(user_CreationTime ? "" + user_CreationTime.toJSON() : "") + "&"; 
        if (user_RoleNames !== undefined)
            user_RoleNames && user_RoleNames.forEach(item => { url_ += "User.RoleNames=" + encodeURIComponent("" + item) + "&"; });
        if (user_PictureUrl !== undefined)
            url_ += "User.PictureUrl=" + encodeURIComponent("" + user_PictureUrl) + "&"; 
        if (user_PictureCoverUrl !== undefined)
            url_ += "User.PictureCoverUrl=" + encodeURIComponent("" + user_PictureCoverUrl) + "&"; 
        if (user_Id !== undefined)
            url_ += "User.Id=" + encodeURIComponent("" + user_Id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveMember(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveMember(<any>response_);
                } catch (e) {
                    return <Observable<PageMemberDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PageMemberDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveMember(response: HttpResponseBase): Observable<PageMemberDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PageMemberDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PageMemberDto[]>(<any>null);
    }
}

@Injectable()
export class PostServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @contentText (optional) 
     * @title (optional) 
     * @comments (optional) 
     * @postData_Pictures (optional) 
     * @postData_MediaLinks (optional) 
     * @postData_Theme (optional) 
     * @postData_Feeling (optional) 
     * @postData_Sticker (optional) 
     * @author_UserName (optional) 
     * @author_EmailAddress (optional) 
     * @author_IsActive (optional) 
     * @author_Name (optional) 
     * @author_FullName (optional) 
     * @author_LastLoginTime (optional) 
     * @author_CreationTime (optional) 
     * @author_RoleNames (optional) 
     * @author_PictureUrl (optional) 
     * @author_PictureCoverUrl (optional) 
     * @author_Id (optional) 
     * @publishType (optional) 
     * @dateCreated (optional) 
     * @stats_PostId (optional) 
     * @stats_Hits (optional) 
     * @stats_Reacts (optional) 
     * @stats_Shares (optional) 
     * @stats_Reposts (optional) 
     * @stats_Stats_IsHit (optional) 
     * @stats_Stats_IsReaction (optional) 
     * @stats_Stats_IsRepost (optional) 
     * @stats_Stats_IsShare (optional) 
     * @stats_Stats_ReactionType (optional) 
     * @stats_UserId (optional) 
     * @return Success
     */
    getPost(id: number | null | undefined, contentText: string | null | undefined, title: string | null | undefined, comments: any[] | null | undefined, postData_Pictures: any[] | null | undefined, postData_MediaLinks: any[] | null | undefined, postData_Theme: string | null | undefined, postData_Feeling: string | null | undefined, postData_Sticker: string | null | undefined, author_UserName: string | null | undefined, author_EmailAddress: string | null | undefined, author_IsActive: boolean | null | undefined, author_Name: string | null | undefined, author_FullName: string | null | undefined, author_LastLoginTime: moment.Moment | null | undefined, author_CreationTime: moment.Moment | null | undefined, author_RoleNames: string[] | null | undefined, author_PictureUrl: string | null | undefined, author_PictureCoverUrl: string | null | undefined, author_Id: number | null | undefined, publishType: string | null | undefined, dateCreated: moment.Moment | null | undefined, stats_PostId: number | null | undefined, stats_Hits: number | null | undefined, stats_Reacts: number | null | undefined, stats_Shares: number | null | undefined, stats_Reposts: number | null | undefined, stats_Stats_IsHit: boolean | null | undefined, stats_Stats_IsReaction: boolean | null | undefined, stats_Stats_IsRepost: boolean | null | undefined, stats_Stats_IsShare: boolean | null | undefined, stats_Stats_ReactionType: ReactionType | null | undefined, stats_UserId: number | null | undefined): Observable<PostDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Post/GetPost?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (contentText !== undefined)
            url_ += "ContentText=" + encodeURIComponent("" + contentText) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (comments !== undefined)
            comments && comments.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Comments[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (postData_Pictures !== undefined)
            postData_Pictures && postData_Pictures.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "PostData.Pictures[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (postData_MediaLinks !== undefined)
            postData_MediaLinks && postData_MediaLinks.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "PostData.MediaLinks[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (postData_Theme !== undefined)
            url_ += "PostData.Theme=" + encodeURIComponent("" + postData_Theme) + "&"; 
        if (postData_Feeling !== undefined)
            url_ += "PostData.Feeling=" + encodeURIComponent("" + postData_Feeling) + "&"; 
        if (postData_Sticker !== undefined)
            url_ += "PostData.Sticker=" + encodeURIComponent("" + postData_Sticker) + "&"; 
        if (author_UserName !== undefined)
            url_ += "Author.UserName=" + encodeURIComponent("" + author_UserName) + "&"; 
        if (author_EmailAddress !== undefined)
            url_ += "Author.EmailAddress=" + encodeURIComponent("" + author_EmailAddress) + "&"; 
        if (author_IsActive !== undefined)
            url_ += "Author.IsActive=" + encodeURIComponent("" + author_IsActive) + "&"; 
        if (author_Name !== undefined)
            url_ += "Author.Name=" + encodeURIComponent("" + author_Name) + "&"; 
        if (author_FullName !== undefined)
            url_ += "Author.FullName=" + encodeURIComponent("" + author_FullName) + "&"; 
        if (author_LastLoginTime !== undefined)
            url_ += "Author.LastLoginTime=" + encodeURIComponent(author_LastLoginTime ? "" + author_LastLoginTime.toJSON() : "") + "&"; 
        if (author_CreationTime !== undefined)
            url_ += "Author.CreationTime=" + encodeURIComponent(author_CreationTime ? "" + author_CreationTime.toJSON() : "") + "&"; 
        if (author_RoleNames !== undefined)
            author_RoleNames && author_RoleNames.forEach(item => { url_ += "Author.RoleNames=" + encodeURIComponent("" + item) + "&"; });
        if (author_PictureUrl !== undefined)
            url_ += "Author.PictureUrl=" + encodeURIComponent("" + author_PictureUrl) + "&"; 
        if (author_PictureCoverUrl !== undefined)
            url_ += "Author.PictureCoverUrl=" + encodeURIComponent("" + author_PictureCoverUrl) + "&"; 
        if (author_Id !== undefined)
            url_ += "Author.Id=" + encodeURIComponent("" + author_Id) + "&"; 
        if (publishType !== undefined)
            url_ += "PublishType=" + encodeURIComponent("" + publishType) + "&"; 
        if (dateCreated !== undefined)
            url_ += "DateCreated=" + encodeURIComponent(dateCreated ? "" + dateCreated.toJSON() : "") + "&"; 
        if (stats_PostId !== undefined)
            url_ += "Stats.PostId=" + encodeURIComponent("" + stats_PostId) + "&"; 
        if (stats_Hits !== undefined)
            url_ += "Stats.Hits=" + encodeURIComponent("" + stats_Hits) + "&"; 
        if (stats_Reacts !== undefined)
            url_ += "Stats.Reacts=" + encodeURIComponent("" + stats_Reacts) + "&"; 
        if (stats_Shares !== undefined)
            url_ += "Stats.Shares=" + encodeURIComponent("" + stats_Shares) + "&"; 
        if (stats_Reposts !== undefined)
            url_ += "Stats.Reposts=" + encodeURIComponent("" + stats_Reposts) + "&"; 
        if (stats_Stats_IsHit !== undefined)
            url_ += "Stats.Stats.IsHit=" + encodeURIComponent("" + stats_Stats_IsHit) + "&"; 
        if (stats_Stats_IsReaction !== undefined)
            url_ += "Stats.Stats.IsReaction=" + encodeURIComponent("" + stats_Stats_IsReaction) + "&"; 
        if (stats_Stats_IsRepost !== undefined)
            url_ += "Stats.Stats.IsRepost=" + encodeURIComponent("" + stats_Stats_IsRepost) + "&"; 
        if (stats_Stats_IsShare !== undefined)
            url_ += "Stats.Stats.IsShare=" + encodeURIComponent("" + stats_Stats_IsShare) + "&"; 
        if (stats_Stats_ReactionType !== undefined)
            url_ += "Stats.Stats.ReactionType=" + encodeURIComponent("" + stats_Stats_ReactionType) + "&"; 
        if (stats_UserId !== undefined)
            url_ += "Stats.UserId=" + encodeURIComponent("" + stats_UserId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPost(<any>response_);
                } catch (e) {
                    return <Observable<PostDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPost(response: HttpResponseBase): Observable<PostDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostDetailDto.fromJS(resultData200) : new PostDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostDetailDto>(<any>null);
    }

    /**
     * @return Success
     */
    getNewsFeedPosts(): Observable<PostDetailDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Post/GetNewsFeedPosts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNewsFeedPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNewsFeedPosts(<any>response_);
                } catch (e) {
                    return <Observable<PostDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetNewsFeedPosts(response: HttpResponseBase): Observable<PostDetailDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(PostDetailDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostDetailDto[]>(<any>null);
    }

    /**
     * @postDetailDto (optional) 
     * @return Success
     */
    addPost(postDetailDto: PostDetailDto | null | undefined): Observable<PostDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Post/AddPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postDetailDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPost(<any>response_);
                } catch (e) {
                    return <Observable<PostDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddPost(response: HttpResponseBase): Observable<PostDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostDetailDto.fromJS(resultData200) : new PostDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostDetailDto>(<any>null);
    }

    /**
     * @postDetailDto (optional) 
     * @return Success
     */
    editPost(postDetailDto: PostDetailDto | null | undefined): Observable<PostDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Post/EditPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(postDetailDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPost(<any>response_);
                } catch (e) {
                    return <Observable<PostDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processEditPost(response: HttpResponseBase): Observable<PostDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostDetailDto.fromJS(resultData200) : new PostDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostDetailDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @contentText (optional) 
     * @title (optional) 
     * @comments (optional) 
     * @postData_Pictures (optional) 
     * @postData_MediaLinks (optional) 
     * @postData_Theme (optional) 
     * @postData_Feeling (optional) 
     * @postData_Sticker (optional) 
     * @author_UserName (optional) 
     * @author_EmailAddress (optional) 
     * @author_IsActive (optional) 
     * @author_Name (optional) 
     * @author_FullName (optional) 
     * @author_LastLoginTime (optional) 
     * @author_CreationTime (optional) 
     * @author_RoleNames (optional) 
     * @author_PictureUrl (optional) 
     * @author_PictureCoverUrl (optional) 
     * @author_Id (optional) 
     * @publishType (optional) 
     * @dateCreated (optional) 
     * @stats_PostId (optional) 
     * @stats_Hits (optional) 
     * @stats_Reacts (optional) 
     * @stats_Shares (optional) 
     * @stats_Reposts (optional) 
     * @stats_Stats_IsHit (optional) 
     * @stats_Stats_IsReaction (optional) 
     * @stats_Stats_IsRepost (optional) 
     * @stats_Stats_IsShare (optional) 
     * @stats_Stats_ReactionType (optional) 
     * @stats_UserId (optional) 
     * @return Success
     */
    deletePost(id: number | null | undefined, contentText: string | null | undefined, title: string | null | undefined, comments: any[] | null | undefined, postData_Pictures: any[] | null | undefined, postData_MediaLinks: any[] | null | undefined, postData_Theme: string | null | undefined, postData_Feeling: string | null | undefined, postData_Sticker: string | null | undefined, author_UserName: string | null | undefined, author_EmailAddress: string | null | undefined, author_IsActive: boolean | null | undefined, author_Name: string | null | undefined, author_FullName: string | null | undefined, author_LastLoginTime: moment.Moment | null | undefined, author_CreationTime: moment.Moment | null | undefined, author_RoleNames: string[] | null | undefined, author_PictureUrl: string | null | undefined, author_PictureCoverUrl: string | null | undefined, author_Id: number | null | undefined, publishType: string | null | undefined, dateCreated: moment.Moment | null | undefined, stats_PostId: number | null | undefined, stats_Hits: number | null | undefined, stats_Reacts: number | null | undefined, stats_Shares: number | null | undefined, stats_Reposts: number | null | undefined, stats_Stats_IsHit: boolean | null | undefined, stats_Stats_IsReaction: boolean | null | undefined, stats_Stats_IsRepost: boolean | null | undefined, stats_Stats_IsShare: boolean | null | undefined, stats_Stats_ReactionType: ReactionType2 | null | undefined, stats_UserId: number | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Post/DeletePost?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (contentText !== undefined)
            url_ += "ContentText=" + encodeURIComponent("" + contentText) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (comments !== undefined)
            comments && comments.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "Comments[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (postData_Pictures !== undefined)
            postData_Pictures && postData_Pictures.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "PostData.Pictures[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (postData_MediaLinks !== undefined)
            postData_MediaLinks && postData_MediaLinks.forEach((item, index) => { 
                for (let attr in item)
                    url_ += "PostData.MediaLinks[" + index + "]." + attr + "=" + encodeURIComponent("" + item[attr]) + "&";
            });
        if (postData_Theme !== undefined)
            url_ += "PostData.Theme=" + encodeURIComponent("" + postData_Theme) + "&"; 
        if (postData_Feeling !== undefined)
            url_ += "PostData.Feeling=" + encodeURIComponent("" + postData_Feeling) + "&"; 
        if (postData_Sticker !== undefined)
            url_ += "PostData.Sticker=" + encodeURIComponent("" + postData_Sticker) + "&"; 
        if (author_UserName !== undefined)
            url_ += "Author.UserName=" + encodeURIComponent("" + author_UserName) + "&"; 
        if (author_EmailAddress !== undefined)
            url_ += "Author.EmailAddress=" + encodeURIComponent("" + author_EmailAddress) + "&"; 
        if (author_IsActive !== undefined)
            url_ += "Author.IsActive=" + encodeURIComponent("" + author_IsActive) + "&"; 
        if (author_Name !== undefined)
            url_ += "Author.Name=" + encodeURIComponent("" + author_Name) + "&"; 
        if (author_FullName !== undefined)
            url_ += "Author.FullName=" + encodeURIComponent("" + author_FullName) + "&"; 
        if (author_LastLoginTime !== undefined)
            url_ += "Author.LastLoginTime=" + encodeURIComponent(author_LastLoginTime ? "" + author_LastLoginTime.toJSON() : "") + "&"; 
        if (author_CreationTime !== undefined)
            url_ += "Author.CreationTime=" + encodeURIComponent(author_CreationTime ? "" + author_CreationTime.toJSON() : "") + "&"; 
        if (author_RoleNames !== undefined)
            author_RoleNames && author_RoleNames.forEach(item => { url_ += "Author.RoleNames=" + encodeURIComponent("" + item) + "&"; });
        if (author_PictureUrl !== undefined)
            url_ += "Author.PictureUrl=" + encodeURIComponent("" + author_PictureUrl) + "&"; 
        if (author_PictureCoverUrl !== undefined)
            url_ += "Author.PictureCoverUrl=" + encodeURIComponent("" + author_PictureCoverUrl) + "&"; 
        if (author_Id !== undefined)
            url_ += "Author.Id=" + encodeURIComponent("" + author_Id) + "&"; 
        if (publishType !== undefined)
            url_ += "PublishType=" + encodeURIComponent("" + publishType) + "&"; 
        if (dateCreated !== undefined)
            url_ += "DateCreated=" + encodeURIComponent(dateCreated ? "" + dateCreated.toJSON() : "") + "&"; 
        if (stats_PostId !== undefined)
            url_ += "Stats.PostId=" + encodeURIComponent("" + stats_PostId) + "&"; 
        if (stats_Hits !== undefined)
            url_ += "Stats.Hits=" + encodeURIComponent("" + stats_Hits) + "&"; 
        if (stats_Reacts !== undefined)
            url_ += "Stats.Reacts=" + encodeURIComponent("" + stats_Reacts) + "&"; 
        if (stats_Shares !== undefined)
            url_ += "Stats.Shares=" + encodeURIComponent("" + stats_Shares) + "&"; 
        if (stats_Reposts !== undefined)
            url_ += "Stats.Reposts=" + encodeURIComponent("" + stats_Reposts) + "&"; 
        if (stats_Stats_IsHit !== undefined)
            url_ += "Stats.Stats.IsHit=" + encodeURIComponent("" + stats_Stats_IsHit) + "&"; 
        if (stats_Stats_IsReaction !== undefined)
            url_ += "Stats.Stats.IsReaction=" + encodeURIComponent("" + stats_Stats_IsReaction) + "&"; 
        if (stats_Stats_IsRepost !== undefined)
            url_ += "Stats.Stats.IsRepost=" + encodeURIComponent("" + stats_Stats_IsRepost) + "&"; 
        if (stats_Stats_IsShare !== undefined)
            url_ += "Stats.Stats.IsShare=" + encodeURIComponent("" + stats_Stats_IsShare) + "&"; 
        if (stats_Stats_ReactionType !== undefined)
            url_ += "Stats.Stats.ReactionType=" + encodeURIComponent("" + stats_Stats_ReactionType) + "&"; 
        if (stats_UserId !== undefined)
            url_ += "Stats.UserId=" + encodeURIComponent("" + stats_UserId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePost(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeletePost(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    addPostComment(model: PostCommentDetailDto | null | undefined): Observable<PostCommentDetailDto> {
        let url_ = this.baseUrl + "/api/services/app/Post/AddPostComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPostComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPostComment(<any>response_);
                } catch (e) {
                    return <Observable<PostCommentDetailDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostCommentDetailDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddPostComment(response: HttpResponseBase): Observable<PostCommentDetailDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostCommentDetailDto.fromJS(resultData200) : new PostCommentDetailDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostCommentDetailDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    updateStat(model: PostStatInput | null | undefined): Observable<PostStatDto> {
        let url_ = this.baseUrl + "/api/services/app/Post/UpdateStat";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStat(<any>response_);
                } catch (e) {
                    return <Observable<PostStatDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostStatDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStat(response: HttpResponseBase): Observable<PostStatDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PostStatDto.fromJS(resultData200) : new PostStatDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostStatDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateRoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: RoleDto | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfPermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfPermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfPermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfPermissionDto.fromJS(resultData200) : new ListResultDtoOfPermissionDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfPermissionDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<RoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<RoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<RoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RoleDto.fromJS(resultData200) : new RoleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RoleDto>(<any>null);
    }

    /**
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleDto.fromJS(resultData200) : new PagedResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }
}

@Injectable()
export class StudentProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @searchQuery (optional) 
     * @return Success
     */
    searchStudents(searchQuery: StudentSearchInput | null | undefined): Observable<SearchStudentOutput> {
        let url_ = this.baseUrl + "/api/services/app/StudentProfile/SearchStudents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(searchQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchStudents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchStudents(<any>response_);
                } catch (e) {
                    return <Observable<SearchStudentOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SearchStudentOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSearchStudents(response: HttpResponseBase): Observable<SearchStudentOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SearchStudentOutput.fromJS(resultData200) : new SearchStudentOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SearchStudentOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getStudentProfile(): Observable<StudentProfileInput> {
        let url_ = this.baseUrl + "/api/services/app/StudentProfile/GetStudentProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStudentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStudentProfile(<any>response_);
                } catch (e) {
                    return <Observable<StudentProfileInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StudentProfileInput>><any>_observableThrow(response_);
        }));
    }

    protected processGetStudentProfile(response: HttpResponseBase): Observable<StudentProfileInput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StudentProfileInput.fromJS(resultData200) : new StudentProfileInput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentProfileInput>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    updateStudentProfile(model: StudentProfileInput | null | undefined): Observable<StudentProfileInput> {
        let url_ = this.baseUrl + "/api/services/app/StudentProfile/UpdateStudentProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateStudentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateStudentProfile(<any>response_);
                } catch (e) {
                    return <Observable<StudentProfileInput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StudentProfileInput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateStudentProfile(response: HttpResponseBase): Observable<StudentProfileInput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StudentProfileInput.fromJS(resultData200) : new StudentProfileInput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StudentProfileInput>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateTenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }

    /**
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfTenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetAll?";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfTenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantDto.fromJS(resultData200) : new PagedResultDtoOfTenantDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: TenantDto | null | undefined): Observable<TenantDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<TenantDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<TenantDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantDto.fromJS(resultData200) : new TenantDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class UploadServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    uploadFile(): Observable<Picture> {
        let url_ = this.baseUrl + "/api/Upload/UploadFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<Picture>><any>_observableThrow(e);
                }
            } else
                return <Observable<Picture>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<Picture> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Picture.fromJS(resultData200) : new Picture();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Picture>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    create(input: CreateUserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: UserDto | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getRoles(): Observable<ListResultDtoOfRoleDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleDto.fromJS(resultData200) : new ListResultDtoOfRoleDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @userName (optional) 
     * @emailAddress (optional) 
     * @isActive (optional) 
     * @fullName (optional) 
     * @avatarPictureUrl (optional) 
     * @coverPictureUrl (optional) 
     * @statusMessage (optional) 
     * @lastLoginTime (optional) 
     * @creationTime (optional) 
     * @id (optional) 
     * @return Success
     */
    getUserTop(userName: string | null | undefined, emailAddress: string | null | undefined, isActive: boolean | null | undefined, fullName: string | null | undefined, avatarPictureUrl: string | null | undefined, coverPictureUrl: string | null | undefined, statusMessage: string | null | undefined, lastLoginTime: moment.Moment | null | undefined, creationTime: moment.Moment | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserTop?";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (fullName !== undefined)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&"; 
        if (avatarPictureUrl !== undefined)
            url_ += "AvatarPictureUrl=" + encodeURIComponent("" + avatarPictureUrl) + "&"; 
        if (coverPictureUrl !== undefined)
            url_ += "CoverPictureUrl=" + encodeURIComponent("" + coverPictureUrl) + "&"; 
        if (statusMessage !== undefined)
            url_ += "StatusMessage=" + encodeURIComponent("" + statusMessage) + "&"; 
        if (lastLoginTime !== undefined)
            url_ += "LastLoginTime=" + encodeURIComponent(lastLoginTime ? "" + lastLoginTime.toJSON() : "") + "&"; 
        if (creationTime !== undefined)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toJSON() : "") + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserTop(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserTop(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserTop(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @userName (optional) 
     * @emailAddress (optional) 
     * @isActive (optional) 
     * @name (optional) 
     * @fullName (optional) 
     * @lastLoginTime (optional) 
     * @creationTime (optional) 
     * @roleNames (optional) 
     * @pictureUrl (optional) 
     * @pictureCoverUrl (optional) 
     * @id (optional) 
     * @return Success
     */
    getUserInfo(userName: string | null | undefined, emailAddress: string | null | undefined, isActive: boolean | null | undefined, name: string | null | undefined, fullName: string | null | undefined, lastLoginTime: moment.Moment | null | undefined, creationTime: moment.Moment | null | undefined, roleNames: string[] | null | undefined, pictureUrl: string | null | undefined, pictureCoverUrl: string | null | undefined, id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserInfo?";
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (emailAddress !== undefined)
            url_ += "EmailAddress=" + encodeURIComponent("" + emailAddress) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&"; 
        if (fullName !== undefined)
            url_ += "FullName=" + encodeURIComponent("" + fullName) + "&"; 
        if (lastLoginTime !== undefined)
            url_ += "LastLoginTime=" + encodeURIComponent(lastLoginTime ? "" + lastLoginTime.toJSON() : "") + "&"; 
        if (creationTime !== undefined)
            url_ += "CreationTime=" + encodeURIComponent(creationTime ? "" + creationTime.toJSON() : "") + "&"; 
        if (roleNames !== undefined)
            roleNames && roleNames.forEach(item => { url_ += "RoleNames=" + encodeURIComponent("" + item) + "&"; });
        if (pictureUrl !== undefined)
            url_ += "PictureUrl=" + encodeURIComponent("" + pictureUrl) + "&"; 
        if (pictureCoverUrl !== undefined)
            url_ += "PictureCoverUrl=" + encodeURIComponent("" + pictureCoverUrl) + "&"; 
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    get(id: number | null | undefined): Observable<UserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/Get?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserDto.fromJS(resultData200) : new UserDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDto>(<any>null);
    }

    /**
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUserDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetAll?";
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserDto.fromJS(resultData200) : new PagedResultDtoOfUserDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserDto>(<any>null);
    }
}

@Injectable()
export class UserProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentProfile(): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/GetCurrentProfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentProfile(<any>response_);
                } catch (e) {
                    return <Observable<UserProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentProfile(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfileDto.fromJS(resultData200) : new UserProfileDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfileDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    updateUserProfile(model: UserProfileDto | null | undefined): Observable<UserProfileDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/UpdateUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<UserProfileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserProfileDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserProfile(response: HttpResponseBase): Observable<UserProfileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserProfileDto.fromJS(resultData200) : new UserProfileDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserProfileDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    changePassword(model: ChangePasswordInput | null | undefined): Observable<IdentityResult> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<IdentityResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<IdentityResult>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<IdentityResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IdentityResult.fromJS(resultData200) : new IdentityResult();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IdentityResult>(<any>null);
    }

    /**
     * @return Success
     */
    getUserPagesDto(): Observable<UserPagesDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/GetUserPagesDto";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPagesDto(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPagesDto(<any>response_);
                } catch (e) {
                    return <Observable<UserPagesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPagesDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPagesDto(response: HttpResponseBase): Observable<UserPagesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserPagesDto.fromJS(resultData200) : new UserPagesDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPagesDto>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    createPage(model: PageDetailDto | null | undefined): Observable<UserPagesDto> {
        let url_ = this.baseUrl + "/api/services/app/UserProfile/CreatePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePage(<any>response_);
                } catch (e) {
                    return <Observable<UserPagesDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserPagesDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePage(response: HttpResponseBase): Observable<UserPagesDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserPagesDto.fromJS(resultData200) : new UserPagesDto();
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("A server error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserPagesDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class ChangeUiThemeInput implements IChangeUiThemeInput {
    theme: string;

    constructor(data?: IChangeUiThemeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): ChangeUiThemeInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUiThemeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        return data; 
    }

    clone(): ChangeUiThemeInput {
        const json = this.toJSON();
        let result = new ChangeUiThemeInput();
        result.init(json);
        return result;
    }
}

export interface IChangeUiThemeInput {
    theme: string;
}

export class PageDetailDto implements IPageDetailDto {
    id: number | undefined;
    userName: string | undefined;
    type: string | undefined;
    email: string | undefined;
    name: string | undefined;
    doB: moment.Moment | undefined;
    phone: string | undefined;
    address: string | undefined;
    country: string | undefined;
    province: string | undefined;
    likeCount: number | undefined;
    followCount: number | undefined;
    city: string | undefined;
    occupation: string | undefined;
    about: string | undefined;
    description: string | undefined;
    websiteUrl: string | undefined;
    facebookUrl: string | undefined;
    twitterUrl: string | undefined;
    skypeName: string | undefined;
    viberNumber: string | undefined;
    pictureUrl: string | undefined;
    coverUrl: string | undefined;
    creationTime: moment.Moment | undefined;
    isVerified: boolean | undefined;
    userId: number | undefined;
    isLiked: boolean | undefined;
    isFollowed: boolean | undefined;
    myRole: PageDetailDtoMyRole | undefined;
    isAdmin: boolean | undefined;
    isEditor: boolean | undefined;
    isModerator: boolean | undefined;

    constructor(data?: IPageDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.type = data["type"];
            this.email = data["email"];
            this.name = data["name"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.phone = data["phone"];
            this.address = data["address"];
            this.country = data["country"];
            this.province = data["province"];
            this.likeCount = data["likeCount"];
            this.followCount = data["followCount"];
            this.city = data["city"];
            this.occupation = data["occupation"];
            this.about = data["about"];
            this.description = data["description"];
            this.websiteUrl = data["websiteUrl"];
            this.facebookUrl = data["facebookUrl"];
            this.twitterUrl = data["twitterUrl"];
            this.skypeName = data["skypeName"];
            this.viberNumber = data["viberNumber"];
            this.pictureUrl = data["pictureUrl"];
            this.coverUrl = data["coverUrl"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isVerified = data["isVerified"];
            this.userId = data["userId"];
            this.isLiked = data["isLiked"];
            this.isFollowed = data["isFollowed"];
            this.myRole = data["myRole"];
            this.isAdmin = data["isAdmin"];
            this.isEditor = data["isEditor"];
            this.isModerator = data["isModerator"];
        }
    }

    static fromJS(data: any): PageDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["type"] = this.type;
        data["email"] = this.email;
        data["name"] = this.name;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["country"] = this.country;
        data["province"] = this.province;
        data["likeCount"] = this.likeCount;
        data["followCount"] = this.followCount;
        data["city"] = this.city;
        data["occupation"] = this.occupation;
        data["about"] = this.about;
        data["description"] = this.description;
        data["websiteUrl"] = this.websiteUrl;
        data["facebookUrl"] = this.facebookUrl;
        data["twitterUrl"] = this.twitterUrl;
        data["skypeName"] = this.skypeName;
        data["viberNumber"] = this.viberNumber;
        data["pictureUrl"] = this.pictureUrl;
        data["coverUrl"] = this.coverUrl;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isVerified"] = this.isVerified;
        data["userId"] = this.userId;
        data["isLiked"] = this.isLiked;
        data["isFollowed"] = this.isFollowed;
        data["myRole"] = this.myRole;
        data["isAdmin"] = this.isAdmin;
        data["isEditor"] = this.isEditor;
        data["isModerator"] = this.isModerator;
        return data; 
    }

    clone(): PageDetailDto {
        const json = this.toJSON();
        let result = new PageDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPageDetailDto {
    id: number | undefined;
    userName: string | undefined;
    type: string | undefined;
    email: string | undefined;
    name: string | undefined;
    doB: moment.Moment | undefined;
    phone: string | undefined;
    address: string | undefined;
    country: string | undefined;
    province: string | undefined;
    likeCount: number | undefined;
    followCount: number | undefined;
    city: string | undefined;
    occupation: string | undefined;
    about: string | undefined;
    description: string | undefined;
    websiteUrl: string | undefined;
    facebookUrl: string | undefined;
    twitterUrl: string | undefined;
    skypeName: string | undefined;
    viberNumber: string | undefined;
    pictureUrl: string | undefined;
    coverUrl: string | undefined;
    creationTime: moment.Moment | undefined;
    isVerified: boolean | undefined;
    userId: number | undefined;
    isLiked: boolean | undefined;
    isFollowed: boolean | undefined;
    myRole: PageDetailDtoMyRole | undefined;
    isAdmin: boolean | undefined;
    isEditor: boolean | undefined;
    isModerator: boolean | undefined;
}

export class PageMemberDto implements IPageMemberDto {
    pageUserName: string | undefined;
    role: PageMemberDtoRole | undefined;
    user: UserInfoDto | undefined;

    constructor(data?: IPageMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pageUserName = data["pageUserName"];
            this.role = data["role"];
            this.user = data["user"] ? UserInfoDto.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PageMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new PageMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageUserName"] = this.pageUserName;
        data["role"] = this.role;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PageMemberDto {
        const json = this.toJSON();
        let result = new PageMemberDto();
        result.init(json);
        return result;
    }
}

export interface IPageMemberDto {
    pageUserName: string | undefined;
    role: PageMemberDtoRole | undefined;
    user: UserInfoDto | undefined;
}

export class UserInfoDto implements IUserInfoDto {
    userName: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    name: string | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    pictureUrl: string | undefined;
    pictureCoverUrl: string | undefined;
    id: number | undefined;

    constructor(data?: IUserInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.name = data["name"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.pictureUrl = data["pictureUrl"];
            this.pictureCoverUrl = data["pictureCoverUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["name"] = this.name;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["pictureUrl"] = this.pictureUrl;
        data["pictureCoverUrl"] = this.pictureCoverUrl;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserInfoDto {
        const json = this.toJSON();
        let result = new UserInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserInfoDto {
    userName: string | undefined;
    emailAddress: string | undefined;
    isActive: boolean | undefined;
    name: string | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    pictureUrl: string | undefined;
    pictureCoverUrl: string | undefined;
    id: number | undefined;
}

export class PostCommentDetailDto implements IPostCommentDetailDto {
    id: number | undefined;
    postId: number | undefined;
    commentText: string | undefined;
    parentId: number | undefined;
    creationTime: moment.Moment | undefined;
    parent: PostCommentDetailDto | undefined;
    children: PostCommentDetailDto[] | undefined;
    userId: number | undefined;
    user: UserInfoDto | undefined;

    constructor(data?: IPostCommentDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.postId = data["postId"];
            this.commentText = data["commentText"];
            this.parentId = data["parentId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.parent = data["parent"] ? PostCommentDetailDto.fromJS(data["parent"]) : <any>undefined;
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [];
                for (let item of data["children"])
                    this.children.push(PostCommentDetailDto.fromJS(item));
            }
            this.userId = data["userId"];
            this.user = data["user"] ? UserInfoDto.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostCommentDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostCommentDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["postId"] = this.postId;
        data["commentText"] = this.commentText;
        data["parentId"] = this.parentId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PostCommentDetailDto {
        const json = this.toJSON();
        let result = new PostCommentDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPostCommentDetailDto {
    id: number | undefined;
    postId: number | undefined;
    commentText: string | undefined;
    parentId: number | undefined;
    creationTime: moment.Moment | undefined;
    parent: PostCommentDetailDto | undefined;
    children: PostCommentDetailDto[] | undefined;
    userId: number | undefined;
    user: UserInfoDto | undefined;
}

export class Picture implements IPicture {
    id: number | undefined;
    pictureBinary: string | undefined;
    mimeType: string | undefined;
    seoFilename: string | undefined;
    fileSize: number | undefined;
    isNew: boolean | undefined;
    pictureUrl: string | undefined;
    width: number | undefined;
    height: number | undefined;
    thumbUrl: string | undefined;
    guid: string | undefined;

    constructor(data?: IPicture) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.pictureBinary = data["pictureBinary"];
            this.mimeType = data["mimeType"];
            this.seoFilename = data["seoFilename"];
            this.fileSize = data["fileSize"];
            this.isNew = data["isNew"];
            this.pictureUrl = data["pictureUrl"];
            this.width = data["width"];
            this.height = data["height"];
            this.thumbUrl = data["thumbUrl"];
            this.guid = data["guid"];
        }
    }

    static fromJS(data: any): Picture {
        data = typeof data === 'object' ? data : {};
        let result = new Picture();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pictureBinary"] = this.pictureBinary;
        data["mimeType"] = this.mimeType;
        data["seoFilename"] = this.seoFilename;
        data["fileSize"] = this.fileSize;
        data["isNew"] = this.isNew;
        data["pictureUrl"] = this.pictureUrl;
        data["width"] = this.width;
        data["height"] = this.height;
        data["thumbUrl"] = this.thumbUrl;
        data["guid"] = this.guid;
        return data; 
    }

    clone(): Picture {
        const json = this.toJSON();
        let result = new Picture();
        result.init(json);
        return result;
    }
}

export interface IPicture {
    id: number | undefined;
    pictureBinary: string | undefined;
    mimeType: string | undefined;
    seoFilename: string | undefined;
    fileSize: number | undefined;
    isNew: boolean | undefined;
    pictureUrl: string | undefined;
    width: number | undefined;
    height: number | undefined;
    thumbUrl: string | undefined;
    guid: string | undefined;
}

export class SocialMedia implements ISocialMedia {
    url: string | undefined;
    title: string | undefined;
    description: string | undefined;
    previewPicture: Picture | undefined;
    previewPictureUrl: string | undefined;
    embedHtml: string | undefined;
    mediaId: string | undefined;
    isSupported: boolean | undefined;
    isGeneric: boolean | undefined;
    provider: ISocialMediaProvider | undefined;
    creationTime: moment.Moment | undefined;
    tenantId: number | undefined;
    id: number | undefined;

    constructor(data?: ISocialMedia) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.title = data["title"];
            this.description = data["description"];
            this.previewPicture = data["previewPicture"] ? Picture.fromJS(data["previewPicture"]) : <any>undefined;
            this.previewPictureUrl = data["previewPictureUrl"];
            this.embedHtml = data["embedHtml"];
            this.mediaId = data["mediaId"];
            this.isSupported = data["isSupported"];
            this.isGeneric = data["isGeneric"];
            this.provider = data["provider"] ? ISocialMediaProvider.fromJS(data["provider"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SocialMedia {
        data = typeof data === 'object' ? data : {};
        let result = new SocialMedia();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["title"] = this.title;
        data["description"] = this.description;
        data["previewPicture"] = this.previewPicture ? this.previewPicture.toJSON() : <any>undefined;
        data["previewPictureUrl"] = this.previewPictureUrl;
        data["embedHtml"] = this.embedHtml;
        data["mediaId"] = this.mediaId;
        data["isSupported"] = this.isSupported;
        data["isGeneric"] = this.isGeneric;
        data["provider"] = this.provider ? this.provider.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SocialMedia {
        const json = this.toJSON();
        let result = new SocialMedia();
        result.init(json);
        return result;
    }
}

export interface ISocialMedia {
    url: string | undefined;
    title: string | undefined;
    description: string | undefined;
    previewPicture: Picture | undefined;
    previewPictureUrl: string | undefined;
    embedHtml: string | undefined;
    mediaId: string | undefined;
    isSupported: boolean | undefined;
    isGeneric: boolean | undefined;
    provider: ISocialMediaProvider | undefined;
    creationTime: moment.Moment | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class ISocialMediaProvider implements IISocialMediaProvider {
    provider: string | undefined;
    systemName: string | undefined;
    regExUrl: string | undefined;
    regExMediaId: string | undefined;
    embedHtml: string | undefined;
    supportApi: boolean | undefined;
    apiUrl: string | undefined;

    constructor(data?: IISocialMediaProvider) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.provider = data["provider"];
            this.systemName = data["systemName"];
            this.regExUrl = data["regExUrl"];
            this.regExMediaId = data["regExMediaId"];
            this.embedHtml = data["embedHtml"];
            this.supportApi = data["supportApi"];
            this.apiUrl = data["apiUrl"];
        }
    }

    static fromJS(data: any): ISocialMediaProvider {
        data = typeof data === 'object' ? data : {};
        let result = new ISocialMediaProvider();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        data["systemName"] = this.systemName;
        data["regExUrl"] = this.regExUrl;
        data["regExMediaId"] = this.regExMediaId;
        data["embedHtml"] = this.embedHtml;
        data["supportApi"] = this.supportApi;
        data["apiUrl"] = this.apiUrl;
        return data; 
    }

    clone(): ISocialMediaProvider {
        const json = this.toJSON();
        let result = new ISocialMediaProvider();
        result.init(json);
        return result;
    }
}

export interface IISocialMediaProvider {
    provider: string | undefined;
    systemName: string | undefined;
    regExUrl: string | undefined;
    regExMediaId: string | undefined;
    embedHtml: string | undefined;
    supportApi: boolean | undefined;
    apiUrl: string | undefined;
}

export class PostDetailDto implements IPostDetailDto {
    id: number | undefined;
    contentText: string | undefined;
    title: string | undefined;
    comments: PostCommentDetailDto[] | undefined;
    postData: PostData | undefined;
    author: UserInfoDto | undefined;
    publishType: string | undefined;
    dateCreated: moment.Moment | undefined;
    stats: PostStatDto | undefined;

    constructor(data?: IPostDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.contentText = data["contentText"];
            this.title = data["title"];
            if (data["comments"] && data["comments"].constructor === Array) {
                this.comments = [];
                for (let item of data["comments"])
                    this.comments.push(PostCommentDetailDto.fromJS(item));
            }
            this.postData = data["postData"] ? PostData.fromJS(data["postData"]) : <any>undefined;
            this.author = data["author"] ? UserInfoDto.fromJS(data["author"]) : <any>undefined;
            this.publishType = data["publishType"];
            this.dateCreated = data["dateCreated"] ? moment(data["dateCreated"].toString()) : <any>undefined;
            this.stats = data["stats"] ? PostStatDto.fromJS(data["stats"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PostDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["contentText"] = this.contentText;
        data["title"] = this.title;
        if (this.comments && this.comments.constructor === Array) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        data["postData"] = this.postData ? this.postData.toJSON() : <any>undefined;
        data["author"] = this.author ? this.author.toJSON() : <any>undefined;
        data["publishType"] = this.publishType;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PostDetailDto {
        const json = this.toJSON();
        let result = new PostDetailDto();
        result.init(json);
        return result;
    }
}

export interface IPostDetailDto {
    id: number | undefined;
    contentText: string | undefined;
    title: string | undefined;
    comments: PostCommentDetailDto[] | undefined;
    postData: PostData | undefined;
    author: UserInfoDto | undefined;
    publishType: string | undefined;
    dateCreated: moment.Moment | undefined;
    stats: PostStatDto | undefined;
}

export class PostData implements IPostData {
    pictures: Picture[] | undefined;
    mediaLinks: SocialMedia[] | undefined;
    theme: string | undefined;
    feeling: string | undefined;
    sticker: string | undefined;

    constructor(data?: IPostData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["pictures"] && data["pictures"].constructor === Array) {
                this.pictures = [];
                for (let item of data["pictures"])
                    this.pictures.push(Picture.fromJS(item));
            }
            if (data["mediaLinks"] && data["mediaLinks"].constructor === Array) {
                this.mediaLinks = [];
                for (let item of data["mediaLinks"])
                    this.mediaLinks.push(SocialMedia.fromJS(item));
            }
            this.theme = data["theme"];
            this.feeling = data["feeling"];
            this.sticker = data["sticker"];
        }
    }

    static fromJS(data: any): PostData {
        data = typeof data === 'object' ? data : {};
        let result = new PostData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.pictures && this.pictures.constructor === Array) {
            data["pictures"] = [];
            for (let item of this.pictures)
                data["pictures"].push(item.toJSON());
        }
        if (this.mediaLinks && this.mediaLinks.constructor === Array) {
            data["mediaLinks"] = [];
            for (let item of this.mediaLinks)
                data["mediaLinks"].push(item.toJSON());
        }
        data["theme"] = this.theme;
        data["feeling"] = this.feeling;
        data["sticker"] = this.sticker;
        return data; 
    }

    clone(): PostData {
        const json = this.toJSON();
        let result = new PostData();
        result.init(json);
        return result;
    }
}

export interface IPostData {
    pictures: Picture[] | undefined;
    mediaLinks: SocialMedia[] | undefined;
    theme: string | undefined;
    feeling: string | undefined;
    sticker: string | undefined;
}

export class PostStatDto implements IPostStatDto {
    postId: number | undefined;
    hits: number | undefined;
    reacts: number | undefined;
    shares: number | undefined;
    reposts: number | undefined;
    stats: PostStatStatus | undefined;
    userId: number | undefined;

    constructor(data?: IPostStatDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.postId = data["postId"];
            this.hits = data["hits"];
            this.reacts = data["reacts"];
            this.shares = data["shares"];
            this.reposts = data["reposts"];
            this.stats = data["stats"] ? PostStatStatus.fromJS(data["stats"]) : <any>undefined;
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): PostStatDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostStatDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["hits"] = this.hits;
        data["reacts"] = this.reacts;
        data["shares"] = this.shares;
        data["reposts"] = this.reposts;
        data["stats"] = this.stats ? this.stats.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): PostStatDto {
        const json = this.toJSON();
        let result = new PostStatDto();
        result.init(json);
        return result;
    }
}

export interface IPostStatDto {
    postId: number | undefined;
    hits: number | undefined;
    reacts: number | undefined;
    shares: number | undefined;
    reposts: number | undefined;
    stats: PostStatStatus | undefined;
    userId: number | undefined;
}

export class PostStatStatus implements IPostStatStatus {
    isHit: boolean | undefined;
    isReaction: boolean | undefined;
    isRepost: boolean | undefined;
    isShare: boolean | undefined;
    reactionType: PostStatStatusReactionType | undefined;

    constructor(data?: IPostStatStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isHit = data["isHit"];
            this.isReaction = data["isReaction"];
            this.isRepost = data["isRepost"];
            this.isShare = data["isShare"];
            this.reactionType = data["reactionType"];
        }
    }

    static fromJS(data: any): PostStatStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PostStatStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isHit"] = this.isHit;
        data["isReaction"] = this.isReaction;
        data["isRepost"] = this.isRepost;
        data["isShare"] = this.isShare;
        data["reactionType"] = this.reactionType;
        return data; 
    }

    clone(): PostStatStatus {
        const json = this.toJSON();
        let result = new PostStatStatus();
        result.init(json);
        return result;
    }
}

export interface IPostStatStatus {
    isHit: boolean | undefined;
    isReaction: boolean | undefined;
    isRepost: boolean | undefined;
    isShare: boolean | undefined;
    reactionType: PostStatStatusReactionType | undefined;
}

export class PostStatInput implements IPostStatInput {
    postId: number | undefined;
    statType: PostStatInputStatType | undefined;
    statReactType: PostStatInputStatReactType | undefined;

    constructor(data?: IPostStatInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.postId = data["postId"];
            this.statType = data["statType"];
            this.statReactType = data["statReactType"];
        }
    }

    static fromJS(data: any): PostStatInput {
        data = typeof data === 'object' ? data : {};
        let result = new PostStatInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["postId"] = this.postId;
        data["statType"] = this.statType;
        data["statReactType"] = this.statReactType;
        return data; 
    }

    clone(): PostStatInput {
        const json = this.toJSON();
        let result = new PostStatInput();
        result.init(json);
        return result;
    }
}

export interface IPostStatInput {
    postId: number | undefined;
    statType: PostStatInputStatType | undefined;
    statReactType: PostStatInputStatReactType | undefined;
}

export class CreateRoleDto implements ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isStatic: boolean | undefined;
    permissions: string[] | undefined;

    constructor(data?: ICreateRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
        }
    }

    static fromJS(data: any): CreateRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }

    clone(): CreateRoleDto {
        const json = this.toJSON();
        let result = new CreateRoleDto();
        result.init(json);
        return result;
    }
}

export interface ICreateRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isStatic: boolean | undefined;
    permissions: string[] | undefined;
}

export class RoleDto implements IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isStatic: boolean | undefined;
    permissions: string[] | undefined;
    id: number | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.normalizedName = data["normalizedName"];
            this.description = data["description"];
            this.isStatic = data["isStatic"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["normalizedName"] = this.normalizedName;
        data["description"] = this.description;
        data["isStatic"] = this.isStatic;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleDto {
        const json = this.toJSON();
        let result = new RoleDto();
        result.init(json);
        return result;
    }
}

export interface IRoleDto {
    name: string;
    displayName: string;
    normalizedName: string | undefined;
    description: string | undefined;
    isStatic: boolean | undefined;
    permissions: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfPermissionDto implements IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(PermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfPermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfPermissionDto {
    items: PermissionDto[] | undefined;
}

export class PermissionDto implements IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;

    constructor(data?: IPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }

    clone(): PermissionDto {
        const json = this.toJSON();
        let result = new PermissionDto();
        result.init(json);
        return result;
    }
}

export interface IPermissionDto {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfRoleDto implements IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleDto {
    totalCount: number | undefined;
    items: RoleDto[] | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    application: ApplicationInfoDto | undefined;
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profile: UserProfileDto | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profile = data["profile"] ? UserProfileDto.fromJS(data["profile"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profile"] = this.profile ? this.profile.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profile: UserProfileDto | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    id: number | undefined;
}

export class UserProfileDto implements IUserProfileDto {
    creationTime: moment.Moment | undefined;
    tenantId: number | undefined;
    id: number | undefined;
    userId: number | undefined;
    userName: string | undefined;
    name: string | undefined;
    email: string | undefined;
    doB: moment.Moment | undefined;
    phone: string | undefined;
    address: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    occupation: string | undefined;
    bio: string | undefined;
    pictureUrl: string | undefined;
    coverUrl: string | undefined;
    marriedStatus: number | undefined;
    facebookUrl: string | undefined;
    twitterUrl: string | undefined;
    skypeName: string | undefined;
    viberNumber: string | undefined;
    user: UserInfoDto | undefined;
    gender: number | undefined;

    constructor(data?: IUserProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.tenantId = data["tenantId"];
            this.id = data["id"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.name = data["name"];
            this.email = data["email"];
            this.doB = data["doB"] ? moment(data["doB"].toString()) : <any>undefined;
            this.phone = data["phone"];
            this.address = data["address"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.occupation = data["occupation"];
            this.bio = data["bio"];
            this.pictureUrl = data["pictureUrl"];
            this.coverUrl = data["coverUrl"];
            this.marriedStatus = data["marriedStatus"];
            this.facebookUrl = data["facebookUrl"];
            this.twitterUrl = data["twitterUrl"];
            this.skypeName = data["skypeName"];
            this.viberNumber = data["viberNumber"];
            this.user = data["user"] ? UserInfoDto.fromJS(data["user"]) : <any>undefined;
            this.gender = data["gender"];
        }
    }

    static fromJS(data: any): UserProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["email"] = this.email;
        data["doB"] = this.doB ? this.doB.toISOString() : <any>undefined;
        data["phone"] = this.phone;
        data["address"] = this.address;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["occupation"] = this.occupation;
        data["bio"] = this.bio;
        data["pictureUrl"] = this.pictureUrl;
        data["coverUrl"] = this.coverUrl;
        data["marriedStatus"] = this.marriedStatus;
        data["facebookUrl"] = this.facebookUrl;
        data["twitterUrl"] = this.twitterUrl;
        data["skypeName"] = this.skypeName;
        data["viberNumber"] = this.viberNumber;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["gender"] = this.gender;
        return data; 
    }

    clone(): UserProfileDto {
        const json = this.toJSON();
        let result = new UserProfileDto();
        result.init(json);
        return result;
    }
}

export interface IUserProfileDto {
    creationTime: moment.Moment | undefined;
    tenantId: number | undefined;
    id: number | undefined;
    userId: number | undefined;
    userName: string | undefined;
    name: string | undefined;
    email: string | undefined;
    doB: moment.Moment | undefined;
    phone: string | undefined;
    address: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    occupation: string | undefined;
    bio: string | undefined;
    pictureUrl: string | undefined;
    coverUrl: string | undefined;
    marriedStatus: number | undefined;
    facebookUrl: string | undefined;
    twitterUrl: string | undefined;
    skypeName: string | undefined;
    viberNumber: string | undefined;
    user: UserInfoDto | undefined;
    gender: number | undefined;
}

export class StudentSearchInput implements IStudentSearchInput {
    deptsList: number[] | undefined;
    yearList: number[] | undefined;
    studentName: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;

    constructor(data?: IStudentSearchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["deptsList"] && data["deptsList"].constructor === Array) {
                this.deptsList = [];
                for (let item of data["deptsList"])
                    this.deptsList.push(item);
            }
            if (data["yearList"] && data["yearList"].constructor === Array) {
                this.yearList = [];
                for (let item of data["yearList"])
                    this.yearList.push(item);
            }
            this.studentName = data["studentName"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): StudentSearchInput {
        data = typeof data === 'object' ? data : {};
        let result = new StudentSearchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.deptsList && this.deptsList.constructor === Array) {
            data["deptsList"] = [];
            for (let item of this.deptsList)
                data["deptsList"].push(item);
        }
        if (this.yearList && this.yearList.constructor === Array) {
            data["yearList"] = [];
            for (let item of this.yearList)
                data["yearList"].push(item);
        }
        data["studentName"] = this.studentName;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): StudentSearchInput {
        const json = this.toJSON();
        let result = new StudentSearchInput();
        result.init(json);
        return result;
    }
}

export interface IStudentSearchInput {
    deptsList: number[] | undefined;
    yearList: number[] | undefined;
    studentName: string | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
}

export class SearchStudentOutput implements ISearchStudentOutput {
    studentProfiles: PagedResultDtoOfStudentProfileDto | undefined;

    constructor(data?: ISearchStudentOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.studentProfiles = data["studentProfiles"] ? PagedResultDtoOfStudentProfileDto.fromJS(data["studentProfiles"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SearchStudentOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SearchStudentOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentProfiles"] = this.studentProfiles ? this.studentProfiles.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SearchStudentOutput {
        const json = this.toJSON();
        let result = new SearchStudentOutput();
        result.init(json);
        return result;
    }
}

export interface ISearchStudentOutput {
    studentProfiles: PagedResultDtoOfStudentProfileDto | undefined;
}

export class PagedResultDtoOfStudentProfileDto implements IPagedResultDtoOfStudentProfileDto {
    totalCount: number | undefined;
    items: StudentProfileDto[] | undefined;

    constructor(data?: IPagedResultDtoOfStudentProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(StudentProfileDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfStudentProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfStudentProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfStudentProfileDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfStudentProfileDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfStudentProfileDto {
    totalCount: number | undefined;
    items: StudentProfileDto[] | undefined;
}

export class StudentProfileDto implements IStudentProfileDto {
    id: number | undefined;
    name: string | undefined;
    studentId: string | undefined;
    pictureUrl: string | undefined;
    birthday: moment.Moment | undefined;
    mobile: string | undefined;
    role: string | undefined;
    address: string | undefined;
    company: string | undefined;
    occupation: string | undefined;
    profession: string | undefined;
    description: string | undefined;
    studentYearId: number | undefined;
    studentDeptId: number | undefined;
    studentClass: string | undefined;
    pictureId: number | undefined;
    link: string | undefined;
    status: number | undefined;
    userId: number | undefined;
    isRegistered: boolean | undefined;
    studentYear: StudentYearDto | undefined;
    studentDept: StudentDeptDto | undefined;

    constructor(data?: IStudentProfileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.studentId = data["studentId"];
            this.pictureUrl = data["pictureUrl"];
            this.birthday = data["birthday"] ? moment(data["birthday"].toString()) : <any>undefined;
            this.mobile = data["mobile"];
            this.role = data["role"];
            this.address = data["address"];
            this.company = data["company"];
            this.occupation = data["occupation"];
            this.profession = data["profession"];
            this.description = data["description"];
            this.studentYearId = data["studentYearId"];
            this.studentDeptId = data["studentDeptId"];
            this.studentClass = data["studentClass"];
            this.pictureId = data["pictureId"];
            this.link = data["link"];
            this.status = data["status"];
            this.userId = data["userId"];
            this.isRegistered = data["isRegistered"];
            this.studentYear = data["studentYear"] ? StudentYearDto.fromJS(data["studentYear"]) : <any>undefined;
            this.studentDept = data["studentDept"] ? StudentDeptDto.fromJS(data["studentDept"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StudentProfileDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentProfileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["studentId"] = this.studentId;
        data["pictureUrl"] = this.pictureUrl;
        data["birthday"] = this.birthday ? this.birthday.toISOString() : <any>undefined;
        data["mobile"] = this.mobile;
        data["role"] = this.role;
        data["address"] = this.address;
        data["company"] = this.company;
        data["occupation"] = this.occupation;
        data["profession"] = this.profession;
        data["description"] = this.description;
        data["studentYearId"] = this.studentYearId;
        data["studentDeptId"] = this.studentDeptId;
        data["studentClass"] = this.studentClass;
        data["pictureId"] = this.pictureId;
        data["link"] = this.link;
        data["status"] = this.status;
        data["userId"] = this.userId;
        data["isRegistered"] = this.isRegistered;
        data["studentYear"] = this.studentYear ? this.studentYear.toJSON() : <any>undefined;
        data["studentDept"] = this.studentDept ? this.studentDept.toJSON() : <any>undefined;
        return data; 
    }

    clone(): StudentProfileDto {
        const json = this.toJSON();
        let result = new StudentProfileDto();
        result.init(json);
        return result;
    }
}

export interface IStudentProfileDto {
    id: number | undefined;
    name: string | undefined;
    studentId: string | undefined;
    pictureUrl: string | undefined;
    birthday: moment.Moment | undefined;
    mobile: string | undefined;
    role: string | undefined;
    address: string | undefined;
    company: string | undefined;
    occupation: string | undefined;
    profession: string | undefined;
    description: string | undefined;
    studentYearId: number | undefined;
    studentDeptId: number | undefined;
    studentClass: string | undefined;
    pictureId: number | undefined;
    link: string | undefined;
    status: number | undefined;
    userId: number | undefined;
    isRegistered: boolean | undefined;
    studentYear: StudentYearDto | undefined;
    studentDept: StudentDeptDto | undefined;
}

export class StudentYearDto implements IStudentYearDto {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IStudentYearDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): StudentYearDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentYearDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): StudentYearDto {
        const json = this.toJSON();
        let result = new StudentYearDto();
        result.init(json);
        return result;
    }
}

export interface IStudentYearDto {
    id: number | undefined;
    name: string | undefined;
}

export class StudentDeptDto implements IStudentDeptDto {
    id: number | undefined;
    name: string | undefined;

    constructor(data?: IStudentDeptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): StudentDeptDto {
        data = typeof data === 'object' ? data : {};
        let result = new StudentDeptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }

    clone(): StudentDeptDto {
        const json = this.toJSON();
        let result = new StudentDeptDto();
        result.init(json);
        return result;
    }
}

export interface IStudentDeptDto {
    id: number | undefined;
    name: string | undefined;
}

export class StudentProfileInput implements IStudentProfileInput {
    studentProfile: StudentProfileDto | undefined;
    deptList: StudentDeptDto[] | undefined;
    yearList: StudentYearDto[] | undefined;

    constructor(data?: IStudentProfileInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.studentProfile = data["studentProfile"] ? StudentProfileDto.fromJS(data["studentProfile"]) : <any>undefined;
            if (data["deptList"] && data["deptList"].constructor === Array) {
                this.deptList = [];
                for (let item of data["deptList"])
                    this.deptList.push(StudentDeptDto.fromJS(item));
            }
            if (data["yearList"] && data["yearList"].constructor === Array) {
                this.yearList = [];
                for (let item of data["yearList"])
                    this.yearList.push(StudentYearDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StudentProfileInput {
        data = typeof data === 'object' ? data : {};
        let result = new StudentProfileInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["studentProfile"] = this.studentProfile ? this.studentProfile.toJSON() : <any>undefined;
        if (this.deptList && this.deptList.constructor === Array) {
            data["deptList"] = [];
            for (let item of this.deptList)
                data["deptList"].push(item.toJSON());
        }
        if (this.yearList && this.yearList.constructor === Array) {
            data["yearList"] = [];
            for (let item of this.yearList)
                data["yearList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StudentProfileInput {
        const json = this.toJSON();
        let result = new StudentProfileInput();
        result.init(json);
        return result;
    }
}

export interface IStudentProfileInput {
    studentProfile: StudentProfileDto | undefined;
    deptList: StudentDeptDto[] | undefined;
    yearList: StudentYearDto[] | undefined;
}

export class CreateTenantDto implements ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantDto {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    connectionString: string | undefined;
    isActive: boolean | undefined;
}

export class TenantDto implements ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantDto {
        const json = this.toJSON();
        let result = new TenantDto();
        result.init(json);
        return result;
    }
}

export interface ITenantDto {
    tenancyName: string;
    name: string;
    isActive: boolean | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfTenantDto implements IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantDto {
    totalCount: number | undefined;
    items: TenantDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.rememberClient = data["rememberClient"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["rememberClient"] = this.rememberClient;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    rememberClient: boolean | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    userId: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
}

export class CreateUserDto implements ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.password = data["password"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["password"] = this.password;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    roleNames: string[] | undefined;
    password: string;
}

export class UserDto implements IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.emailAddress = data["emailAddress"];
            this.isActive = data["isActive"];
            this.fullName = data["fullName"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            if (data["roleNames"] && data["roleNames"].constructor === Array) {
                this.roleNames = [];
                for (let item of data["roleNames"])
                    this.roleNames.push(item);
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["emailAddress"] = this.emailAddress;
        data["isActive"] = this.isActive;
        data["fullName"] = this.fullName;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        if (this.roleNames && this.roleNames.constructor === Array) {
            data["roleNames"] = [];
            for (let item of this.roleNames)
                data["roleNames"].push(item);
        }
        data["id"] = this.id;
        return data; 
    }

    clone(): UserDto {
        const json = this.toJSON();
        let result = new UserDto();
        result.init(json);
        return result;
    }
}

export interface IUserDto {
    userName: string;
    name: string;
    surname: string;
    emailAddress: string;
    isActive: boolean | undefined;
    fullName: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment | undefined;
    roleNames: string[] | undefined;
    id: number | undefined;
}

export class ListResultDtoOfRoleDto implements IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleDto {
    items: RoleDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class PagedResultDtoOfUserDto implements IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserDto {
    totalCount: number | undefined;
    items: UserDto[] | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    userId: number | undefined;
    currentPassword: string | undefined;
    newPassword: string | undefined;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordInput {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    userId: number | undefined;
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class IdentityResult implements IIdentityResult {
    succeeded: boolean | undefined;
    errors: IdentityError[] | undefined;

    constructor(data?: IIdentityResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.succeeded = data["succeeded"];
            if (data["errors"] && data["errors"].constructor === Array) {
                this.errors = [];
                for (let item of data["errors"])
                    this.errors.push(IdentityError.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IdentityResult {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (this.errors && this.errors.constructor === Array) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item.toJSON());
        }
        return data; 
    }

    clone(): IdentityResult {
        const json = this.toJSON();
        let result = new IdentityResult();
        result.init(json);
        return result;
    }
}

export interface IIdentityResult {
    succeeded: boolean | undefined;
    errors: IdentityError[] | undefined;
}

export class IdentityError implements IIdentityError {
    code: string | undefined;
    description: string | undefined;

    constructor(data?: IIdentityError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): IdentityError {
        data = typeof data === 'object' ? data : {};
        let result = new IdentityError();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["description"] = this.description;
        return data; 
    }

    clone(): IdentityError {
        const json = this.toJSON();
        let result = new IdentityError();
        result.init(json);
        return result;
    }
}

export interface IIdentityError {
    code: string | undefined;
    description: string | undefined;
}

export class UserPagesDto implements IUserPagesDto {
    pageCredit: number | undefined;
    userId: number | undefined;
    pages: PageDetailDto[] | undefined;

    constructor(data?: IUserPagesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pageCredit = data["pageCredit"];
            this.userId = data["userId"];
            if (data["pages"] && data["pages"].constructor === Array) {
                this.pages = [];
                for (let item of data["pages"])
                    this.pages.push(PageDetailDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserPagesDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPagesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCredit"] = this.pageCredit;
        data["userId"] = this.userId;
        if (this.pages && this.pages.constructor === Array) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserPagesDto {
        const json = this.toJSON();
        let result = new UserPagesDto();
        result.init(json);
        return result;
    }
}

export interface IUserPagesDto {
    pageCredit: number | undefined;
    userId: number | undefined;
    pages: PageDetailDto[] | undefined;
}

export enum MyRole {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum MyRole2 {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum Role {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ReactionType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
}

export enum ReactionType2 {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum PageDetailDtoMyRole {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum PageMemberDtoRole {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum PostStatStatusReactionType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
}

export enum PostStatInputStatType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export enum PostStatInputStatReactType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
    _5 = 5, 
    _6 = 6, 
    _7 = 7, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}